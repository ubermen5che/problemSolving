package programmers.level2.eatground;

/**
 * 문제 이름 : 땅고르기
 * 레벨 : 2
 * 문제 유형 : DP
 * 문제 설명 : 땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때
 * 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.
 *
 * 예를 들면,
 *
 * | 1 | 2 | 3 | 5 |
 *
 * | 5 | 6 | 7 | 8 |
 *
 * | 4 | 3 | 2 | 1 |
 *
 * 로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.
 *
 * 마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.
 *
 *
 *
 * 해결 방법 : DP를 사용해서 쉽게 해결할 수 있었다. 이전 단계에서 얻은 최대점수가 다음 단계에서의 최대점수를 도출할 때 사용이 되는점에서 DP접근 방법의 핵심
 * 큰문제와 작은문제간의 연관관계를 찾을 수 있었다. DP를 이용하면 n-1번째에서 가질 수 있는 최대점수를 계산할 수 있고 n단계에서 n-1단계의 값을 이용해서 최대점수를 도출해준다.
 *
 * 문제 회고 : 처음 문제를 분석할 때 DP를 사용해볼 수 있지 않을까 생각했지만 DP문제를 많이 접해보지않아서 다른 방법을 찾았던 것 같다.
 * DP를 사용하지 않고 단순히 for문으로 n번째 까지의 row들을 순회하면서 각 row에 대한 최대값을 도출해주는 방식을 사용했다. 대신 최대값을 도출할때는
 * 같은 열을 연속해서 내려갈 수 없다는 조건을 고려해서 현재 row에서 최대값이 존재하는 index를 저장해서 다음 row에서 최대값을 계산할 때 저장했던 이전 단계의
 * 최대값 index를 제외시켜주는 방식으로 답을 구했었다. 그러나 이런식으로 하면 당연하게도 최대 점수를 얻지못하게된다(단순 그리디로는 해결못함) DP 유형에 대해
 * 아직 익숙하지 않아서 문제 접근을 잘못했던것이 문제였던것 같다.
 *
 *
 *
 *
 *
 */
public class EatTheGround {

    class Solution {
        int solution(int[][] land) {
            int answer = 0;

            for (int i = 1; i < land.length; i++){
                land[i][0] += max(land[i-1][1], land[i-1][2], land[i-1][3]);
                land[i][1] += max(land[i-1][0], land[i-1][2], land[i-1][3]);
                land[i][2] += max(land[i-1][0], land[i-1][1], land[i-1][3]);
                land[i][3] += max(land[i-1][0], land[i-1][1], land[i-1][2]);
            }

            return max(land[land.length-1]);
        }

        private int max(int a, int b, int c){
            return Math.max(Math.max(a,b), c);
        }

        private int max(int[] arr){
            int max = 0;

            for (int i = 0; i < arr.length; i++){
                if (max < arr[i])
                    max = arr[i];
            }

            return max;
        }
    }
}
