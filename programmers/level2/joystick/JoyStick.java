package programmers.level2.joystick;

/**
 * 문제 이름 : 조이스틱
 * 유형 : greedy
 * 문제 url : https://programmers.co.kr/learn/courses/30/lessons/42860
 *
 * 해결 설명
 * 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
 * ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA
 *
 * 조이스틱을 각 방향으로 움직이면 아래와 같습니다.
 *
 * ▲ - 다음 알파벳
 * ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
 * ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
 * ▶ - 커서를 오른쪽으로 이동
 *
 * - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
 * - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
 * - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
 * 따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
 *
 * 해법 : 초기에는 모두 'A'로 초기화되어있다. 일반적인 경우에 예를들어 "BDEF"의 경우 의심의 여지 없이 초기문자 'A'에서 부터 B,...F 모두 처리해주어야 한다.
 * 이 따라서 A -> B (1) A -> D (3) ... 이러한 방법을 거쳐 총 16회의 이동이 발생한다. 이 경우에 단순히 각 문자에 대해 위아래 방향 조작에 대한 cost
 * 그리고 단순 오른쪽 이동 cost를 더해주면 간단하다. 그러나 BBBAAAAABA와 같은 경우가 문제가 된다. 단순히 오른쪽으로만 이동해서는 최소의 이동횟수가 될 수 없다.
 * 따라서 일반적인 방법대로 오른쪽 이동을 하면서 이후 문자가 'A'가 나타나는지 확인해주고 얼마나 연속되어 나타나는지 체크해주어야한다. 체크를 하는 이유는 이러한 최소 이동
 * 횟수를 코드에 볼 수 있듯이 다음과 같은 수식으로 일반화 해볼 수 있기 때문이다. min = (i * 2) + (nameLen - nextIndex) 여기서 i는 현재 name 문자열에서
 * 도달한 위치를 나타내고 nameLen은 name의 길이 nextIndex는 다음 Index에 A가 존재할 때 A의 도달index를 뜻한다. 위에 예에 적용해보자면. 6이 나오고
 * 정확히 6번의 이동만으로 처리가 가능하게된다.
 *
 * 어려웠던 점 : 아직 그리디 알고리즘에 익숙치 않은것 같다. 처음 제출을 했을때 45.5점이 나왔는데. 원인은 연속된 A가 나올경우에 대해서 적절히 처리를 하지 못했기
 * 때문이었던 것 같다. 내가 가진 구현력으로는 아직 생각이 많이 필요한 문제같았다. 그리고 문자간의 이동거리를 계산할 때 별도의 메서드를 선언하고 반복문을 사용해서 처리
 * 했었는데 삼항연산자를 사용해서 간단히 계산할 수 있었던 부분을 캐치못했다. 또한 연속된 문자가 출현시 문제가 될것을 직감했지만 해당 부분을 구현해서 문제를 해결하진 못했다.
 * 아직 문제에 대한 일반화 능력이 부족한것 같다. 어떻게 아래와 같은 수식을 도출 할 수 있었을까. 차근차근 생각해보면 매우 이해가 되는데 단번에 생각나지는 않을것 같다...
 */

public class JoyStick {

    class Solution {
        public int solution(String name) {
            int answer = 0;
            int len = name.length();

            // 제일 짧은 좌, 우 이동은 그냥 맨 오른쪽으로 이동할 때(연속된 A가 존재할경우)
            int min = len - 1;

            for (int i = 0; i < len; i++) {
                // 조이스틱 상, 하 이동
                char c = name.charAt(i);
                int mov = (c - 'A' < 'Z' - c + 1) ? (c - 'A') : ('Z' - c + 1);
                answer += mov;

                // 조이스틱 좌, 우 이동
                int nextIndex = i + 1;
                // 다음 단어가 A이고, 단어가 끝나기 전까지 nextIndex 증가
                while (nextIndex < len && name.charAt(nextIndex) == 'A')
                    nextIndex++;

                min = Math.min(min, (i * 2) + len - nextIndex);
            }

            answer += min;

            return answer;
        }
    }
}
